# 观察者模式/装饰者模式

### 设计原则

> 为了交互对象之间的松耦合设计而努力。（观察者篇）

> 类应该对扩展开放，对修改关闭。（装饰者篇）

```
我们的目标是允许类容易拓展，在不修改现有代码的情况下，就可以搭配新的行为。如果是实现这样的目标，有什么好处呢？这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。

每个地方都采用开放-关闭原则是一种浪费，也没有必要，还会导致代码变得复杂且难以理解。
```

### 设计模式

> **观察者模式**:定义了对象之间的**一对多**依赖，这样一来，当一个对象（Subject）改变状态时，他的所有依赖（Observer）着都会受到通知并自动更新。（观察者篇）

```
Subject是真正拥有数据的人，Observer是主题的依赖者，只有一个对象控制这份数据。
```

> **装饰者模式**：动态地将职责附加到对象上。若要扩展功能，装饰者提供了必成更有弹性的代替方案。

```
- 装饰者和被装饰者对象有相同的超类型
- 集成抽象类，是为了有正确的类型，而不是继承它的行为。
```
**详见下图**

*观察者篇*

![结构图](/Resources/01-观察者模式-01.png)

<!-- ![结构图](/Resources/01-观察者模式-02.png) -->

<!-- ![结构图](/Resources/01-观察者模式-03.png) -->

*装饰者篇*

![结构图](/Resources/01-观察者模式-04.png)

![结构图](/Resources/01-观察者模式-05.png)

**解释：装饰者和被装饰者类型要统一。**

##### 杂七杂八

**观察者模式**， 可以选择从被观察者处 推/拉  数据。（观察者篇）

**装饰者模式**，会在设计中引入大量的小类。一旦使用装饰者模式，不只需要实例化组件，还需要把此组件包装进入装饰者中。只有在针对抽象组件类型编程时，才不会因为装饰而受到影响，如果针对特定的具体组件编程，就可能出问题，要看是否需要继续使用这种模式。（装饰者模式）
